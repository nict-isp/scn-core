# -*- coding: utf-8 -*-
#
# Copyright (c) 2016, National Institute of Information and Communications Technology. All rights reserved. 
# GPL3, see LICENSE for more details. 
#
require 'logger'
require 'singleton'

require_relative '../../utils'
require_relative '../../app_if'

#= DSN description automatic execution processing class
# Get the DSN description generated by create_dsn API from a given directory, 
# generates a channel using the create_overlay API.
#
#@author NICT
#
class DSNAutoExecutor
    include Singleton

    #@return [Hash]  DSN description in the automatic execution
    attr_reader   :running_dsn

    def initialize()
        log_trace()

        @running_dsn = {}
    end

    # Initial setting
    #
    #@param [Integer] interval  Operation period of DsnAutoExecutor
    #
    def setup(interval)
        @dsn_store_path     = $config[:dsn_store_path]
        @dsn_file_ext       = $config[:dsn_file_ext]
        @dsn_log_store_path = $config[:dsn_log_store_path]
        @dsn_log_file_ext   = $config[:dsn_log_file_ext]

        start(interval)
    end

    #@return [Hash] DSN description(key:overlay name)
    #
    def gather_dsn_files()
        dsn_requests = {}
        dsn_files = Dir.glob(@dsn_store_path + "/*" + @dsn_file_ext)

        dsn_files.each do |dsn_file|
            File.open(dsn_file, "r") do |rfile|
                if rfile.flock(File::LOCK_EX|File::LOCK_NB)
                    overlay_name = File.basename(dsn_file, @dsn_file_ext)
                    dsn_requests[overlay_name] = rfile.read
                else
                    next # During the another process locked to execute the following processing without waiting for.
                end
            end # It is unlocked at the time of File.close execute.
        end
        return dsn_requests
    end

    #@param [String] overlay_name  Overlay name(= file name)
    #@param [String] dsn_desc      DSN description
    #@return [String] DSN description file storage path
    #@note Extension will be granted automatically.
    #
    def store_dsn_file(overlay_name, dsn_desc)
        dsn_file = @dsn_store_path + '/' + overlay_name + @dsn_file_ext

        File.open(dsn_file, "w") do |wfile|
            wfile.flock(File::LOCK_EX)
            # During the separate process lock(read) wait here.
            wfile.write(dsn_desc)
        end # It is unlocked at the time of File.close execute.

        return dsn_file
    end

    #@param [String] overlay_id  Overlay ID
    #@param [String] message     Message
    #
    def log_auto_execute_message(overlay_id, message)
        overlay = @running_dsn.select {|key, val| val["id"] == overlay_id } # Only one can be acquired.
        overlay_name = overlay.keys[0]
        log_file = @dsn_log_store_path + '/' + overlay_name + @dsn_log_file_ext

        File.open(log_file, "a") do |wfile|
            wfile.puts(message)
        end
    end

    private

    # To start the periodic execution thread.
    #
    #@param [Integer] interval  Operation period of DsnAutoExecutor
    #
    def start(interval)
        Thread.new do
            loop do
                begin
                    log_trace()
                    update_overlays_from_dsn_files()
                rescue
                    log_error("", $!)
                end

                sleep interval
            end
        end
    end

    # Cycle execution process
    #
    def update_overlays_from_dsn_files()
        log_time()

        requests_dsn = gather_dsn_files()
        requests_names = requests_dsn.keys
        running_names = @running_dsn.keys

        # create
        (requests_names - running_names).each do |overlay_name|
            dsn_desc = requests_dsn[overlay_name]
            create_overlay(overlay_name, dsn_desc)
        end

        # delete
        (running_names - requests_names).each do |overlay_name|
            delete_overlay(overlay_name)
        end

        # update
        (requests_names & running_names).each do |overlay_name|
            dsn_desc = requests_dsn[overlay_name]
            if dsn_desc == @running_dsn[overlay_name]["dsn"]
                # no chage
            else
                # To change the overlay
                modify_overlay(overlay_name, dsn_desc)
            end
        end

        log_time()
    end

    #@param [String] overlay_name  Overlay name(=DSN file name)
    #@param [String] dsn_desc      DSN description
    #
    def create_overlay(overlay_name, dsn_desc)
        overlay_id = ApplicationRPCServer.create_overlay(overlay_name, dsn_desc, nil)
        @running_dsn[overlay_name] = { "id" => overlay_id, "dsn" => dsn_desc }
    end

    #@param [String] overlay_name  Overlay name(=DSN file name)
    #
    def delete_overlay(overlay_name)
        ApplicationRPCServer.delete_overlay(@running_dsn[overlay_name]["id"])
        @running_dsn.delete(overlay_name)
    end

    #@param [String] overlay_name  Overlay name(=DSN file name)
    #@param [String] dsn_desc      DSN description
    #
    def modify_overlay(overlay_name, dsn_desc)
        ApplicationRPCServer.modify_overlay(overlay_name, @running_dsn[overlay_name]["id"], dsn_desc)
        @running_dsn[overlay_name]["dsn"] = dsn_desc
    end

    # Delegate instance method to class
    class << self
        extend Forwardable
        def_delegators :instance, *DSNAutoExecutor.instance_methods(false)
    end
end

